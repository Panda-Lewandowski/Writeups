<h1>Скрывать не скрывая. Еще раз о LSB-стеганографии, хи-квадрате и… сингулярности?</h1>

Сегодня снова поворошим старое гнездо и поговорим о том, как скрыть кучку бит в картинке с котиком, посмотрим на
несколько доступных инструментов и разберем самые популярные атаки. И казалось бы, при чем тут сингулярность?

Как говорится, если хочешь в чем-то разобраться, то напиши об этом статью на Хабр! (Осторожно, много текста и картинок)

<img src="https://habrastorage.org/webt/v9/ti/s6/v9tis6oz_wa4wuftwtkfnmbjeis.jpeg" />

<cut />
<b>Стеганография</b> (дословно с греческого «тайнопись») — наука передачи скрываемых данных (стегосообщения) в других
открытых данных (стегоконтейнеров) при сокрытии самого факта передачи данных. Не пугайтесь, на самом деле все не так
сложно.

Итак, в каком месте изображения можно спрятать сообщение так, чтобы никто не заметил?

А мест всего два: метаданные и само изображение. Последнее совсем простое, достаточно набрать в гугле <i>«exif»</i>.
Так что начнем, пожалуй, сразу со второго.

<h2>Least Significant Bit</h2>
Наиболее популярной цветовой моделью является RGB, где цвет представляется в виде трех составляющих: красного, зеленого
и голубого. Каждая компонента кодируется в классическом варианте с помощью 8 бит, то есть может принимать значение от 0
до 255. Именно здесь и прячется наименее значащий бит. Важно понять, что на один RGB-цвет приходится приходится аж три
таких бита.

Чтобы представить их более наглядно, проделаем пару небольших манипуляций.

Как и было обещано, возьмем картинку с котиком в png формате.
<img src="https://habrastorage.org/webt/-_/zw/4o/-_zw4olg0ichesidkgofldi58mo.png" />

Разобьем её на три канала и в каждом канале возьмем наименее значащий бит. Создадим три новых изображения, где каждый
пиксель обозначает НЗБ. Ноль — пиксель белый, единица соответственно черный.

Получаем вот что.
> Красный канал
    <img src="https://habrastorage.org/webt/dk/38/kl/dk38klwfaswulkmvwbxwp03tc1k.png" />


> Зеленый канал
    <img src="https://habrastorage.org/webt/r8/46/w2/r846w2bagdkbqldhsu4jpudsxok.png" />


> Синий канал
    <img src="https://habrastorage.org/webt/h5/6g/2m/h56g2mwmxal8atd1dihgzgbsp5m.png" />


Но, как правило, изображение встречается в «собранном виде». Чтобы представить НЗБ трех компонент в одном изображении,
достаточно компоненту в пикселе, где НЗБ равен единице, заменить на 255, и в обратном случае заменить на 0.

> Тогда получается вот это
    <img src="https://habrastorage.org/webt/zi/ul/xz/ziulxz5-afu8udbhizjabtniccm.png" />
    Может засунем сюда что-нибудь?


<h2>Но не менее значимый</h2>
Представим, что все, что мы видели на последней картинке, это наше и мы в праве делать с этим все, что угодно. Тогда
возьмем это как поток битов, откуда мы можем читать и куда мы можем записывать.

Берем данные, которые мы хотим вкрапить в изображение, представляем их в виде битов и последовательно записываем на
место уже существующих.

Для извлечения этих данных прочитаем НЗБ как битовый поток и приведем к нужному виду. Чтобы узнать, сколько битов нужно
считать, как правило, в начало записывают размер сообщения. Но это уже детали реализации.

Нужно отметить, что примерно в 50% случаев бит, который мы хотим записать, и бит в картинке будут совпадать и изменять
нам ничего не придется.

Вот и все, на этом метод заканчивается.

<h2>Почему это работает?</h2>
Посмотрите на изображения ниже.

Это незаполненный стегоконтейнер:
<img src="https://habrastorage.org/webt/-_/zw/4o/-_zw4olg0ichesidkgofldi58mo.png" />

А это заполненный на 95%:

<img src="https://habrastorage.org/webt/fk/co/u8/fkcou8eyserz_g2usxm3a7_0jgy.png" />

Видите разницу? А она есть. Почему так?

Посмотрим на два цвета: (0, 0, 0) и (1, 1, 1), то есть на цвета, различные только НЗБ в каждой компоненте.

<img src="https://habrastorage.org/webt/ti/g4/f1/tig4f1wc1xkh0vtgtrud2ncz82u.png" />

Небольшие различия в пикселях при первом, втором и третьем взгляде, заметны не будут. Дело в том, что наш глаз может
различить около 10 миллионов цветов, а мозг всего лишь около 150. Модель RGB же содержит 16 777 216 цветов. Попробовать
различить их все можно <a href="https://pikabu.ru/story/yeto_izobrazhenie_soderzhit_vse_16_777_216_tsvetov_rgb_2051137">здесь.</a>

<h2>Из командной строки</h2>
Существует не так много работающих command line тулз в открытом доступе, представляющих LSB-стеганографию.
Самые популярные можно найти в таблице внизу.

||||||
|--- |--- |--- |--- |--- |
|Тулза|Типы файлов|Описание|Сокрытие|Извлечение|
|openstego|PNG|Может использоваться не только для сокрытия данных, но и для водяных знаков. Использует RandomLSB -
улучшенный алгоритм LSB с записью в Random Least Significant Bit. Поддерживает шифрование. Имеет также GUI.|openstego embed -mf secret.txt -cf cover.png -p password -sf stego.png|openstego extract -sf openstego.png -p abcd -xf output.txt|
|stegano|PNG|Работает не только с классическим LSB. Имеет гибкую настройку. Может использоваться как модуль Python.
Самая привлекательная (как по мне).|stegano-lsb hide --input cover.jpg -f secret.txt -e UTF-8 --output stego.png|stegano-lsb reveal -i stego.png -e UTF-8 -o output.txt|
|cloackedpixel|PNG, JPG|Простенькая тулза. Плохо справляется с большим сообщением. (Точнее вообще никак) Поддерживает шифрование.|cloackedpixel hide cover.jpg secret.txt password|cloackedpixel extract cover.jpg-stego.png output.txt password|
|LSBSteg|PNG, BMP|Небольшая программа на Python c читабельным кодом.|LSBSteg encode -i cover.png -o stego.png -f secret.txt|LSBSteg decode -i stego.png -o output.txt|


<h2>А где котик?</h2>

И первой в списке атак на LSB-стеганографию выступает визуальная атака. Звучит странно, не правда ли? Ведь котик с
секретом никак не выдавал себя как заполненный стегоконтейнер на первый взгляд. Хммм… Нужно всего лишь знать, куда
смотреть. Несложно догадаться, что нашего пристального внимания заслуживают только НЗБ.
У заполненого стегоконтейнера изображение с НЗБ выглядит так:

<img src="https://habrastorage.org/webt/fz/yo/p-/fzyop-5d_32fk0_xsasldipxhmm.png" />

Не верите? Вот вам НЗБ со всех трех каналов отдельно:
> Красный канал
    <img src="https://habrastorage.org/webt/h1/x2/s6/h1x2s60e6949hh-fir07kucc-9y.png" />


> Зеленый канал
    <img src="https://habrastorage.org/webt/ui/1j/fj/ui1jfjd4o3w5d433z4cutmtnw-4.png" />


> Синий канал
    <img src="https://habrastorage.org/webt/jh/o7/ve/jho7veslry4xc2vmontyxvcrypq.png" />


Это специфичный для сокрытия сообщения «рисунок» в НЗБ. На первый взгляд это кажется простым шумом. Но при рассмотрении
проглядывается структура. Здесь видно, что стегоконтейнер заполнен под завязку. Если бы мы взяли сообщение в 30% от
вместимости бедного котика, то получили такую бы картину:

> Контейнер
    <img src="https://habrastorage.org/webt/w_/bu/jw/w_bujwr_igtdivi2qoflv-7fmdo.png" />


Его НЗБ:
<img src="https://habrastorage.org/webt/bg/5j/bc/bg5jbcic5s4deqbit3gh6bwli_s.png" />

~70% котика осталось неизменным.

Тут стоит сделать небольшое отступление и поговорить о размерах. Что такое 30% котика? Размер котика 603х433 пикселей.
30% от этого размера равны 78459 пикселям. В каждый пиксель помещается 3 бита информации. Итого 78459 * 3 =
235377 бит или чуть меньше, чем 30 килобайт помещается в 30% котика. А в целого котика поместится около 100 килобайт.
Такие дела.

Но мы же здесь вами не просто так. Как же все-таки обмануть глаза?
Первая мысль: засунуть сообщение в шум. Но не тут то было. Далее фрагмент заполненного стегоконтейнера и его LSB.

<img src="https://habrastorage.org/webt/lf/9_/gw/lf9_gwnpkub5yre9gvy5rffbmvc.png" />

Прикладывая небольшое усилие, мы все-таки можем различить знакомую структуру. Не теряем надежды, господа!

<h2>Хи-хи-хи</h2>

Много вещей ломается статистикой, знаете ли.

Изменяя что-то в картинке, мы меняем её статистические свойства. Аналитику достаточно найти способ эти изменения
зафиксировать.

Старый добрый хи-квадрат для этого начали использовать Андреас Весфилд и Андреас Пфитцманн из Университета Дрездена в
своей работе «Attacks on Steganographic Systems», которую можно найти <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.94.5975&rep=rep1&type=pdf">здесь.</a>


Здесь и далее будем говорить об атаках в рамках одной цветовой плоскости, или в контексте RGB об атаках на один канал.
Результаты каждой атаки можно привести к среднему и получить результат для «собранного» изображения.

Итак, атака "Хи-квадрат" основывается на том предположении, что вероятность одновременного появления соседних (отличных
на наименее значащий бит) цветов (pair of values) в незаполненном стегоконтейнере крайне мала. Это действительно так,
можешь поверить. Если говорить другими словами, то количество пикселей двух соседних цветов существенно отличается для
пустого контейнера. Все, что нам нужно сделать, это посчитать количество пикселей каждого цвета и применить пару
формул. На самом деле, это простая задачка на проверку гипотезы с использованием критерия хи-квадрат.
Немного математики?

Пусть h - массив, на i-ом месте содержащий количество пикселей i-ого цвета в исследуемом изображении.

Тогда:
<ol>
    <li>
        Измеренная частота появления цвета i:
        <img src="https://render.githubusercontent.com/render/math?math=n_k = h[2k], ~k \in [0, 127];">
    </li>
    <li>
        Теоретически ожидаемая частота появления цвета i:
        <img src="https://render.githubusercontent.com/render/math?math=n_k^*=\frac{h[2k]%2Bh[2k%2B1]}{2}, ~k \in [0,127];">
    </li>
</ol>
Переводя это на Python получится что-то вроде этого:

```python
for k in range(0, len(histogram) // 2):
    expected.append(((histogram[2 * k] + histogram[2 * k + 1]) / 2))
    observed.append(histogram[2 * k])
```

Где histogram — количество пикселей цвета i в изображении, <img src="https://render.githubusercontent.com/render/math?math=i \in [0, 255]&mode=inline">

Хи-квадрат критерий для количества степеней свободы k-1 рассчитывается следующим образом (k — количество различных
цветов, то есть 256):
<img src="https://render.githubusercontent.com/render/math?math=\chi_{k-1}^2 = \sum_{i=1}^{k} \frac{(n_k - n_k^*)^2}{n_k^*};">

И, наконец, P — это вероятность того, что распределения <img src="https://render.githubusercontent.com/render/math?math=n_i&mode=inline"> и <img src="https://render.githubusercontent.com/render/math?math=n_i^*&mode=inline"> при этих условиях
равны (вероятность того, что перед нами заполненый стегоконтейнер). Она рассчитывается при помощи интегрирования
функции гладкости:
<img src="https://render.githubusercontent.com/render/math?math=P = 1 - \frac{1}{2^{\frac{k-1}{2}}\Gamma(\frac{k-1}{2})}\int_0^{\chi_{k-1}^2} e^{-\frac{x}{2}}x^{\frac{k-1}{2}-1} dx;">

Эффективнее всего применять хи-квадрат не ко всему изображению, а только к его частям, например, к строкам. Если
посчитанная вероятность для строки больше 0.5, то строку в оригинальном изображении закрасим красным. Если меньше, то
зеленым. Для котика с 30% заполненностью, картина будет выглядеть следующим образом:

<img src="https://habrastorage.org/webt/qx/bw/8f/qxbw8fft7e3o3jpjnxa0yfs75uo.png" />

Весьма точно, неправда ли?

Ну вот мы и обзавелись математически обоснованной атакой, математику-то не обманешь! Или…??

<h2>Shuffle Dance</h2>
Идея довольно проста: записывать биты не по порядку, а в случайные места. Для этого надо взять ГПСЧ, настроить его на
выдачу одного и того же потока случайности при одном и том же сиде (aka пароле). Не зная пароля, мы не сможем настроить
ГПСЧ и найти пиксели, в которых спрятано сообщение.
Испытаем это на котике.

Котик (32% заполнености):

<img src="https://habrastorage.org/webt/cc/q1/am/ccq1amsbp1myq3as8sm-u5tiueq.png" />

Его LSB:

<img src="https://habrastorage.org/webt/yt/ry/ls/ytrylso2qnksal03w4bdrqkjbes.png" />

Картинка выглядит шумной, но не подозрительной для неопытного аналитика. А что говорит Хи-квадрат?


"А что говорит Хи-квадрат?">
    <img src="https://habrastorage.org/webt/ww/hb/yh/wwhbyhiz9p_acmm7ecpc_qrwwc8.png" />


Кажется, black hat победили!? Как бы не так...

<h2>Регулярность-сингулярность</h2>
Еще один статистический метод был Джессикой Фридрих, Мирославом Гольяном и Андреасом Пфитцманом в 2001 году. Он был
назван как RS-метод. Оригинальную статью можно взять <a href="http://www.ws.binghamton.edu/fridrich/Research/acm_2001_03.pdf">здесь.</a>

Метод содержит несколько подготовительных этапов.

Изображение разделяется на группы из n пикселей. К примеру, 4 последовательных пикселя в строке. Как правило, такие
группы содержат рядом стоящие пиксели.
Для нашего котика с последовательным заполнением в красном канале первыми пятью группами будут:
<ul>
    <li>
        [78, 78, 79, 78]
    </li>
    <li>
        [78, 78, 78, 78]
    </li>
    <li>
        [78, 79, 78, 79]
    </li>
    <li>
        [79, 76, 79, 76]
    </li>
    <li>
        [76, 76, 76, 77]
    </li>
</ul>

(Все измерения приводятся в классическом варианте RGB)

Затем мы определяем так называемую дискриминант-функцию или функцию гладкости, которая сопоставляет каждой группе
пикселей действительно число. Цель это функции состоит в том, чтобы зафиксировать гладкость или «регулярность» группы
пикселей G. Чем шумнее группа пикселей <img src="https://render.githubusercontent.com/render/math?math=G=(x_1, ... , x_n)">, тем большее значение дискриминант-функция
будет иметь. Чаще всего выбирают «вариацию» группы пикселей или, проще говоря, сумму разностей соседних пикселей в
группе. Но так же в ней можно учесть статистические предположения об изображении.

<img src="https://render.githubusercontent.com/render/math?math=f(x_1, x_2, ..., x_n) = \sum_{i=1}^{n-1} |x_{i+1}- x_i|">

Значения функции гладкости для группы пикселей из нашего примера:
<ul>
    <li>f(78, 78, 79, 78) = 2</li>
    <li>f(78, 78, 78, 78) = 0</li>
    <li>f(78, 79, 78, 79) = 3</li>
    <li>f(79, 76, 79, 76) = 9</li>
    <li>f(76, 76, 76, 77) = 1</li>
</ul>



Далее определяется класс функций флиппинга от одного пикселя.

Они должны обладать некоторыми свойствами.
<img src="https://render.githubusercontent.com/render/math?math=1.\forall x \in P: ~F(F(x)) = x, ~~P=\{0, ~255\};">

<img src="https://render.githubusercontent.com/render/math?math=2.F_1: 0\leftrightarrow 1, 2\leftrightarrow 3,..., 254\leftrightarrow 255;">

<img src="https://render.githubusercontent.com/render/math?math=3.\forall x \in P: ~ F_{-1}(x) = F_1(x+1)-1;">


Где <img src="https://render.githubusercontent.com/render/math?math=F&mode=inline"> - любая функция из одного класса, <img src="https://render.githubusercontent.com/render/math?math=F_1&mode=inline"> - прямая функция флиппинга , а
<img src="https://render.githubusercontent.com/render/math?math=F_{-1}&mode=inline"> - обратная. В дополнение обычно обозначается тождественная функция флиппинга
<img src="https://render.githubusercontent.com/render/math?math=F_0&mode=inline">, которая не меняет пиксель.

Функции флиппинга на python могут выглядеть примерно вот так:
```python
def flip(val):
    if val & 1:
        return val - 1
    return val + 1


def invert_flip(val):
    if val & 1:
        return val + 1
    return val - 1

def null_flip(val):
    return val
```

К каждой группе пикселей мы применяем одну из функций флиппинга и на основании значения функции-дескриминанта до и
после флиппинга, мы определяем тип группы пикселей: обычный (<b>R</b>egular), единичный/необычный (<b>S</b>ingular) , и
<s>бесполезный</s> непригодный (unusable). Так как последний тип в дальнейшем не используется, метод был назван по
первым буквам ключевых типов. Вот и весь секрет названия, сингулярность здесь ни при чем :)

<img src="https://habrastorage.org/webt/ox/l3/ri/oxl3ri73jtyi0roa8lncitbclig.png" />

Мы можем <s>захотеть</s> применить разный флиппинг к разным пикселям, для этого определяют маску М с n значениями -1, 0
или 1.

<img src="https://render.githubusercontent.com/render/math?math=F_M(G) = (F_{M(1)}(x_1), F_{M(2)}(x_2),..., F_{M(n)}(x_n))">

Пусть маска для нашего примера будет классическая — [1, 0, 0, 1]. Опытным путем было обнаружено, что лучше всего для
этого метода подходят симметричные маски, не содержащие <img src="https://render.githubusercontent.com/render/math?math=F_{-1}&mode=inline">. Также удачными вариантами будут: [0, 1,
0, 1], [0, 1, 1, 0], [1, 0, 1, 0].
Применим флиппинг для групп из примера, подсчитаем значение гладкости и определим тип группы пикселей:
<ul>
    <li><img src="https://render.githubusercontent.com/render/math?math=F_M(78, 78, 79, 78) = [79, 78, 79, 79];&mode=inline">
    <li><img src="https://render.githubusercontent.com/render/math?math=f(79, 78, 79, 79) = 2 = 2 = f(78, 78, 79, 78)&mode=inline">
    <li>Unusable группа </li>
    </li>
    </li>
    <li><img src="https://render.githubusercontent.com/render/math?math=F_M(78, 78, 78, 78) = [79, 78, 78, 79];&mode=inline">
    <li><img src="https://render.githubusercontent.com/render/math?math=f(79, 78, 78, 79) = 2 > 0 = f(78, 78, 78, 78)&mode=inline">
    <li>Regular группа</li>
    </li>
    </li>
    <li><img src="https://render.githubusercontent.com/render/math?math=F_M(78, 79, 78, 79) = [79, 79, 78, 78];&mode=inline">
    <li><img src="https://render.githubusercontent.com/render/math?math=f(79, 79, 78, 78) = 1 < 3=f(78, 79, 78, 79)&mode=inline"> 
    <li>Singular группа </li>
    </li>
    </li>
    <li><img src="https://render.githubusercontent.com/render/math?math=F_M(79, 76, 79, 76) = [78, 76, 79, 77];&mode=inline">
    <li> <img src="https://render.githubusercontent.com/render/math?math=f(78, 76, 79, 77) = 7 < 9=f(79, 76, 79, 76)&mode=inline">
    <li>Singular группа </li>
    </li>
    </li>
    <li><img src="https://render.githubusercontent.com/render/math?math=F_M(76, 76, 76, 77) = [77, 76, 76, 76];&mode=inline">
    <li><img src="https://render.githubusercontent.com/render/math?math=f(77, 76, 76, 76) = 1 = 1 = f(76, 76, 76, 77)&mode=inline">
    <li>Unusable группа</li>
    </li>
    </li>
</ul>


Обозначим число регулярных групп для маски M как <img src="https://render.githubusercontent.com/render/math?math=R_M&mode=inline"> (в процентных долях всех групп), и
<img src="https://render.githubusercontent.com/render/math?math=S_M&mode=inline"> для сингулярных групп.

Тогда <img src="https://render.githubusercontent.com/render/math?math=R_M + S_M \leq 1&mode=inline"> и <img src="https://render.githubusercontent.com/render/math?math=R_{-M} + S_{-M} \leq 1&mode=inline">, для отрицательной маски (все
компоненты маски умножены на -1), т.к. <img src="https://render.githubusercontent.com/render/math?math=R_M + S_M + U_M = 1&mode=inline">, при этом <img src="https://render.githubusercontent.com/render/math?math=U_M&mode=inline"> может быть
пустой. Аналогично для отрицательной маски.

Основная статистическая гипотеза состоит в том, что в типичном изображении ожидаемое значение <img src="https://render.githubusercontent.com/render/math?math=R_M&mode=inline"> равно
значению <img src="https://render.githubusercontent.com/render/math?math=R_{-M}&mode=inline">, и то же самое верно для <img src="https://render.githubusercontent.com/render/math?math=S_M&mode=inline"> и <img src="https://render.githubusercontent.com/render/math?math=S_{-M}&mode=inline">. Это доказывают
экспериментальные данные и некоторые танцы с бубном вокруг последнего свойства функции флиппинга.

<img src="https://render.githubusercontent.com/render/math?math=R_M \cong S_M">

<img src="https://render.githubusercontent.com/render/math?math=R_{-M} \cong S_{-M}">

Проверим это на нашем маленьком примере? Учитывая небольшой размер выборки, мы можем не подтвердить данную гипотезу.
Посмотрим, что же будет с инвертированной маской: [-1, 0, 0, -1].
<ul>
    <li>F_M(78, 78, 79, 78) = [77, 78, 79, 77];
    <li>f(77, 78, 79, 77) = 4 > 2 = f(77, 78, 79, 77)
    <li>Regular группа </li>
    </li>
    </li>
    <li>F_M(78, 78, 78, 78) = [77, 78, 78, 77];
    <li>f(77, 78, 78, 77) = 2 > 0 = f(78, 78, 78, 78)
    <li>Regular группа </li>
    </li>
    </li>
    <li>F_M(78, 79, 78, 79) = [77, 79, 78, 80];
    <li>f(77, 79, 78, 80) = 5 > 3 = f(78, 79, 78, 79)
    <li>Regular группа </li>
    </li>
    </li>
    <li>F_M(79, 76, 79, 76) = [80, 76, 79, 75];
    <li> f(80, 76, 79, 75) = 11 > 9 = f(79, 76, 79, 76)
    <li>Regular группа </li>
    </li>
    </li>
    <li>F_M(76, 76, 76, 77) = [75, 76, 76, 78];
    <li>f(75, 76, 76, 78) = 3 > 1 = f(76, 76, 76, 77)
    <li>Regular группа </li>
    </li>
    </li>
</ul>

Ну тут все очевидно.

Однако разность между <img src="https://render.githubusercontent.com/render/math?math=R_M&mode=inline"> и <img src="https://render.githubusercontent.com/render/math?math=S_M&mode=inline"> стремиться к нулю по мере увеличения длины m
встроенного сообщения и мы получаем, что <img src="https://render.githubusercontent.com/render/math?math=R_M \cong S_M&mode=inline">.

Забавно, что рандомизация плоскости LSB оказывает противоположное влияние на <img src="https://render.githubusercontent.com/render/math?math=R_{-M}&mode=inline"> и
<img src="https://render.githubusercontent.com/render/math?math=S_{-M}&mode=inline">. Их разность увеличивается с длиной m встроенного сообщения. Объяснение этому явлению можно
найти в оригинальной статье.

Вот график <img src="https://render.githubusercontent.com/render/math?math=R_M&mode=inline">, <img src="https://render.githubusercontent.com/render/math?math=S_M&mode=inline">, <img src="https://render.githubusercontent.com/render/math?math=R_{-M}&mode=inline"> и <img src="https://render.githubusercontent.com/render/math?math=S_{-M}&mode=inline"> в зависимости от
количества пикселей с инвертированными LSB, его называют RS-диаграммой. Ось x представляет собой процент пикселей с
инвертированными LSB, ось y - относительное число регулярных и сингулярных групп с масками M и -M, <img src="https://render.githubusercontent.com/render/math?math=M=[0110]&mode=inline">.

<img src="https://habrastorage.org/webt/x7/za/j0/x7zaj0htci_ql6xjz13koohjbnk.png" />

Суть метода RS-стегоанализа заключается в оценке четырех кривых диаграммы RS и вычислении их пересечения с
использованием экстраполяции. Предположим, что у нас есть стегоконтейнер с сообщением неизвестной длины p (в процентах
от пикселей), встроенное в младшие разряды случайно выбранных пикселей (то есть с использованием RandomLSB).
Наши начальные измерения числа групп R и S соответствуют точкам <img src="https://render.githubusercontent.com/render/math?math=R_M(p / 2)&mode=inline">, <img src="https://render.githubusercontent.com/render/math?math=S_M(p / 2)&mode=inline">,
<img src="https://render.githubusercontent.com/render/math?math=R_{-M}(p / 2)&mode=inline"> и <img src="https://render.githubusercontent.com/render/math?math=S_{-M}(p / 2)&mode=inline">. Мы берем точки именно от половины длины сообщения, так
как сообщение является случайным битовым потоком и в среднем, как было сказано ранее, только одна половина пикселей
будет изменена посредством внедрения сообщения.

Если мы инвертируем LSB всех пикселей на изображении и вычислим количество R и S групп, мы получим четыре точки
<img src="https://render.githubusercontent.com/render/math?math=R_M(1-p / 2)&mode=inline">, <img src="https://render.githubusercontent.com/render/math?math=S_M(1-p / 2)&mode=inline">, <img src="https://render.githubusercontent.com/render/math?math=R_{-M}(1-p / 2)&mode=inline"> и <img src="https://render.githubusercontent.com/render/math?math=S_{-M}(1-p /
2)&mode=inline">. 
Поскольку эти две точки зависят от конкретной рандомизации LSB, мы должны многократно повторять этот процесс и
оценивать <img src="https://render.githubusercontent.com/render/math?math=R_M(1/2)&mode=inline"> и <img src="https://render.githubusercontent.com/render/math?math=S_M(1/2)&mode=inline"> из статистических выборок.

Мы можем условно провести прямые через точки <img src="https://render.githubusercontent.com/render/math?math=R_{-M}(p / 2)&mode=inline">, <img src="https://render.githubusercontent.com/render/math?math=R_{-M}(1-p / 2)&mode=inline"> и
<img src="https://render.githubusercontent.com/render/math?math=S_{-M}(p / 2)&mode=inline">, <img src="https://render.githubusercontent.com/render/math?math=S_{-M}(1-p / 2)&mode=inline">. 

Точки <img src="https://render.githubusercontent.com/render/math?math=R_M(p / 2)&mode=inline">, <img src="https://render.githubusercontent.com/render/math?math=R_M(1 / 2)&mode=inline">, <img src="https://render.githubusercontent.com/render/math?math=R_M(1-p / 2)&mode=inline"> и <img src="https://render.githubusercontent.com/render/math?math=S_M(p /
2)&mode=inline">, <img src="https://render.githubusercontent.com/render/math?math=S_M(1 / 2)&mode=inline">, <img src="https://render.githubusercontent.com/render/math?math=S_M(1-p / 2)&mode=inline"> определяют две параболы. Каждая парабола и
соответствующая линия пересекаются слева. Среднее арифметическое x-координат обоих пересечений позволяет оценить
неизвестную длину сообщения p. 

Чтобы избежать долгой статистической оценки средних точек RM(1/2) и SM(1/2), можно принять еще пару соображений:

<ol>
    <li>Точка пересечения кривых <img src="https://render.githubusercontent.com/render/math?math=R_M&mode=inline"> и <img src="https://render.githubusercontent.com/render/math?math=R_{-M}&mode=inline"> имеет ту же координату x, что и точка
        пересечения для кривых <img src="https://render.githubusercontent.com/render/math?math=S_M&mode=inline"> и <img src="https://render.githubusercontent.com/render/math?math=S_{-M}&mode=inline">. Это по существу более строгая версия нашей
        статистической гипотезы. (см. выше)</li>
    <li>Кривые RM и SM пересекаются при m = 50%, или <img src="https://render.githubusercontent.com/render/math?math=R_M(1/2) = S_M(1/2)&mode=inline">. </li>
</ol>


Эти два предположения позволяют получить простую формулу для длины секретного сообщения p. После масштабирования оси x,
так что p / 2 становится 0, а 1 - p / 2 становится равным 1, x-координата точки пересечения является корнем из
следующего квадратного уравнения

<img src="https://habrastorage.org/webt/aw/mf/br/awmfbrlhfetlkp_bxawmjj-tm1e.png" />

Тогда длину сообщения можно вычислить по формуле:

<img src="https://render.githubusercontent.com/render/math?math=p = \frac{x}{x-\frac{1}{2}}">

Тут на сцену выходит наш котик. (Не пора ли дать ему имя?)

Итак, у нас имеется:
<ul>
    <li>Regular групп RM(p/2): 23121 шт.</li>
    <li>Singular групп SM(p/2): 14124 шт.</li>
    <li>Regular групп с инвертированной маской R-M(p/2): 37191 шт.</li>
    <li>Singular групп с инвертированной маской S-M(p/2): 8440 шт.</li>
    <li>Regular групп с инвертированными LSB RM(1-p/2): 20298 шт.</li>
    <li>Singular групп с инвертированными LSB SM(1-p/2): 16206 шт.</li>
    <li>Regular групп с инвертированными LSB и с инвертированной маской R-M(1-p/2): 40603 шт.</li>
    <li>Singular групп с инвертированными LSB и с инвертированной маской S-M(1-p/2): 6947 шт. </li>
</ul>
(Если у вас очень много свободного времени, то можете подсчитать их самостоятельно, а пока предлагаю поверить мои
подсчетам)

На повестке дня у нас осталась одна голая математика. Все же помнят, как решать квадратные уравнения?

<img src="https://render.githubusercontent.com/render/math?math=d_0 = 8997 ">
<img src="https://render.githubusercontent.com/render/math?math=d_{-0} =28751">
<img src="https://render.githubusercontent.com/render/math?math=d_1 = 4092">
<img src="https://render.githubusercontent.com/render/math?math=d_{-1} = 33656">

Подставив все d в формулу выше, получим квадратное уравнение, которое решим, как учили в школе.

<img src="https://render.githubusercontent.com/render/math?math=26178x^2-35988x - 19754 = 0">
<img src="https://render.githubusercontent.com/render/math?math=D = (-35988)^2 - 4*26178*(-19754) = 3363616992">
<img src="https://render.githubusercontent.com/render/math?math=x_1 = 1.7951">
<img src="https://render.githubusercontent.com/render/math?math=x_2 = -0.4204">

Возьмем меньший по модулю корень, то есть <img src="https://render.githubusercontent.com/render/math?math=x_2&mode=inline">. Тогда примерная оценка для встроенного в котика
сообщения будет такая:

<img src="https://render.githubusercontent.com/render/math?math=p = \frac{1.7951}{1.7951 - 0.5} = 0.4567">

Да, у этого метода есть один большой плюс и один большой минус. Плюс заключается в том, что метод работает как с
обычной LSB-стеганографией, так и RandomLSB-стеганографией. Хи-квадрат такой возможностью похвастаться не может. Нашего
рандомного котика метод распознал точно и дал оценку длине сообщения в 0.3256, что очень-очень точно.

Минус же кроется в большой (очень большой) погрешности данного метода, растущей вместе с длинной сообщения <i>при
последовательном встраивании</i>. К примеру, для котика с заполненностью в 30% моя реализация метода дает примерную
среднюю оценку на три канала в 0.4633 или в 46% от общей вместимости, при заполненности более 95% — 0.8597. Зато для
пустого котика аж 0.0054. И это общая тенденция, не зависящая от реализации. Наиболее точные результаты при обычном LSB
метод дает при длине встраиваемого сообщение в 10%+-5%.

<h2>Плюс-минус</h2>

Чтобы не попасться, надо быть неожиданным и использовать ±1 кодирование. Вместо того чтобы изменять наименьший значащий
бит в байте цвета, мы будем весь байт либо увеличивать, либо уменьшать на единицу. Есть только два исключения:
<ul>
    <li>
        мы не можем уменьшить ноль, поэтому мы будем его увеличивать,
    </li>
    <li>
        мы также не можем увеличить 255, так что это значение мы всегда будем уменьшать.
    </li>
</ul>

Для всех других значений байта мы совершенно случайно выбираем либо увеличение на единицу, либо уменьшение. Поверх
данной манипуляции LSB будет изменяться так, как менялся раньше. Для пущей надежности лучше брать случайные байты для
записи сообщения.
Вот наш друг котик:

<img src="https://habrastorage.org/webt/ml/qb/hq/mlqbhqewxue5dnpikkdqxi-rwt8.png" />

Внешне внедрение незаметно ровно по той же причине, почему не было видны разницы между (0, 0, 0) и (1, 1, 1).

<img src="https://habrastorage.org/webt/kq/hf/vr/kqhfvr88yymkfmjqianm84ngc04.png" />

Срез LSB остается просто шумным из-за записи в случайные места.

<img src="https://habrastorage.org/webt/mz/_w/9f/mz_w9fmttcnw7xojazukcsznhhg.png" />

Хи-квадрат по-прежнему слеп, а RS-метод дает приблизительную оценку <b>0.0036</b>.

Чтобы не очень сильно радоваться, прочтите вот <a href="http://www.cipr.rpi.edu/%7Epearlman/papers/harmsEI03.pdf">эту</a>
статью.

У самых внимательных может возникнуть вопрос, как же мы можем достать сообщение, если целые байты изменяются случайно,
а пароля для настаивания ГПСЧ у нас нет (лучше использовать разные сиды aka состояния генератора aka пароли для работы
с RandomLSB и ±1 кодированием). Ответ максимально прост. Мы достаем сообщение так же, как это делали и без ±1
кодирования. Мы вообще можем не знать о его использовании. Повторюсь, данную уловку мы используем <i>только для обхода
автоматических средств детектирования</i>. При внедрении/извлечении сообщения мы работаем только с его LSB и ничем
более. Однако при детектировании нам необходимо брать во внимание контекст внедрения, то есть все байты изображения,
чтобы построить статистические оценки. Именно в этом и заключается весь успех ±1 кодирования.

<h2>Вместо заключения</h2>
Еще одна весьма неплохая попытка использовать статистику против LSB-стеганографии была предпринята в методе под
названием Sample Pairs. Найти его можно <a href="http://www.ece.mcmaster.ca/~sorina/papers/LSBfinalTSP.pdf">здесь.</a>
Его присутствие здесь сделало бы статью слишком академичной, поэтому заинтересованным оставляю это для внеклассного
чтения. Но предвосхищая вопросы аудитории, отвечу сразу: нет, он не ловит ±1 кодирование.

И конечно машинное обучение. Современные методы на основе ML дают очень хорошие результаты. Об этом можно почитать <a
    href="https://pdfs.semanticscholar.org/100f/78a5a7bae59544ad5de7aa4c011ebc01bd9a.pdf">тут</a> и <a href="http://www.ists.dartmouth.edu/library/34.pdf">тут</a>.

По мотивам этой статьи была написана (пока) небольшая <a href="https://github.com/Panda-Lewandowski/StegMachine">тулза</a>.
Она может генерировать данные, осуществлять визуальную атаку раздельно по каналам, подсчитывать RS-, SPA-оценку и
визуализировать результаты Хи-квадрат. И она не собирается на этом останавливаться.

Подводя черту, хочется дать пару советов:
<ul>
    <li>Внедряйте сообщение в случайные байты.</li>
    <li>Максимально уменьшайте объем внедряемой информации (вспоминаем дядюшку Хэмминга).</li>
    <li>Используйте ±1 кодирование.</li>
    <li>Выбирайте картинки с шумным LSB.</li>
    <li>Будьте паиньками!</li>
</ul>
Буду рада увидеть ваши предложения, дополнения, исправления и другой feedback!
